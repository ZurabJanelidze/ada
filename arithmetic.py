import ada

ada.notebook("Arithmetic")

arithmetic = ada.argument(theme="theory", name="arithmetic", dialect="natural")

_inf_=ada.note(ada.exp("[]:[]"), "Abbreviated as: {\_}inf{\_}")
X=ada.exp("X")
Y=ada.exp("Y")
x=ada.exp("x")
y=ada.exp("y")
F=ada.exp("F []")
G=ada.exp("G []")

istrue = arithmetic.assume("is true", name="is true")
_equiv_ = arithmetic.assume("[] <=> []", name="equivalence")
_equal_ = arithmetic.assume("[] = []", name="equality")
false_ = arithmetic.assume("false []", name="fallacy")
_isfalse = arithmetic.assume("[] is false", name="negation")
num_ = arithmetic.assume("number []", name="number")
zero = arithmetic.assume("0", name="zero")
_isnat = arithmetic.assume("[] is a natural number", name="is a number")
_suc = arithmetic.assume("[]+1", name="successor")

introEquiv = arithmetic.assume(_inf_((X,Y,_inf_(X,Y),_inf_(Y,X)),_equiv_(X,Y)), name="introduction of equivalence")
elimEquivI = arithmetic.assume(_inf_((X,Y,_equiv_(X,Y)),_inf_(X,Y)), name="elimination of equivalence I")
elimEquivII = arithmetic.assume(_inf_((X,Y,_equiv_(X,Y)),_inf_(Y,X)), name="elimination of equivalence II")
defEq = arithmetic.assume(_inf_((X,Y),_equiv_(_equal_(X,Y),_inf_((F,G),_equiv_(F(X),F(Y))))), name="definition of equality")
defFallacy = arithmetic.assume(_equiv_(false_(istrue),_inf_(X,X)), name="definition of fallacy")
defNeg = arithmetic.assume(_inf_(X,_equiv_(_isfalse(X),_inf_(X,false_(istrue)))), name="definition of negation")
zeroNum = arithmetic.assume(_isnat(num_(zero)), name="zero is a natural number")
sucNum = arithmetic.assume(_inf_((x,_isnat(x)),(_isnat(_suc(x)))), name="successor of a natural number is a natural number")
arithI = arithmetic.assume(_inf_(x,_isfalse(_equal_(num_(zero),_suc(x)))), name="zero is not a successor")
arithII = arithmetic.assume(_inf_((x,y),_inf_(_equal_(_suc(x),_suc(y)),_equal_(x,y))), name="successor is injective")
arithIII = arithmetic.assume(_inf_((F,F(num_(zero)),_inf_((x,_isnat(num_(x)),F(num_(x))),F(_suc(num_(x))))),_inf_((x,_isnat(x)),F(x))), name="induction principle")

E = ada.argument(arithmetic,theme="hidden", dialect="natural")
E.assume(F,G,F(istrue),_equiv_(F(istrue),G(istrue)))
EE = E.conclude(elimEquivI, F(istrue), G(istrue))
E.conclude(EE)
E.conclude()

elimEquivIII = arithmetic.conclude(E)
E.proof()

E = ada.argument(arithmetic,theme="hidden", dialect="natural")
E.assume(F,G,G(istrue),_equiv_(F(istrue),G(istrue)))
EE = E.conclude(elimEquivII, F(istrue), G(istrue))
E.conclude(EE)
E.conclude()

elimEquivIV = arithmetic.conclude(E)
E.proof()

E = ada.argument(arithmetic,theme="hidden", dialect="natural")
E.assume(F,F(istrue),_isfalse(F(istrue)))
E.conclude(defNeg, F(istrue))
EE=E.conclude(elimEquivIII, _isfalse(F(istrue)), _inf_(F(istrue),false_(istrue)))
E.conclude(EE)
E.conclude()

introFalseI = arithmetic.conclude(E)
E.proof()

E = ada.argument(arithmetic,theme="hidden", dialect="natural")
E.assume(F,_inf_(F(istrue),false_(istrue)))
E.conclude(defNeg, F(istrue))
EE=E.conclude(elimEquivII, _isfalse(F(istrue)),_inf_(F(istrue),false_(istrue)))
E.conclude(EE)
E.conclude()

introIsFalse = arithmetic.conclude(E)
E.proof()

E = ada.argument(arithmetic,theme="hidden", dialect="natural")
E.assume(G, F,_inf_(G(istrue),F(istrue)),_isfalse(F(istrue)))
D = ada.argument(E)
D.assume(G(istrue))
D.conclude(_inf_(G(istrue),F(istrue)))
D.conclude(introFalseI, F(istrue))
D.conclude()
E.conclude(D)
E.conclude(introIsFalse, G(istrue))
E.conclude()

inherIsFalse = arithmetic.conclude(E)
E.proof()

E = ada.argument(arithmetic,theme="hidden", dialect="natural")
E.conclude(arithI, num_(zero))
A = ada.argument(E)
A.assume(x,_isnat(num_(x)))
A.assume(_isfalse(_equal_(num_(x),_suc(num_(x)))))
A.conclude(arithII, num_(x), _suc(num_(x)))
A.conclude(inherIsFalse, _equal_(_suc(num_(x)),_suc(_suc(num_(x)))), _equal_(num_(x),_suc(num_(x))))
A.conclude()
E.conclude(A)
E.conclude(arithIII, [_isfalse(_equal_("",_suc(""))),[1,1]])
E.conclude()

arithmetic.conclude(E)
E.proof("fitch")
